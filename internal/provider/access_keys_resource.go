// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/team-fenrir/terraform-provider-storagegrid/internal/utils"
)

var (
	_ resource.Resource              = &AccessKeysResource{}
	_ resource.ResourceWithConfigure = &AccessKeysResource{}
)

// NewAccessKeysResource creates a new instance of the AccessKeysResource.
func NewAccessKeysResource() resource.Resource {
	return &AccessKeysResource{}
}

// AccessKeysResource is the resource implementation for a single S3 access key.
type AccessKeysResource struct {
	client *utils.Client
}

// AccessKeysResourceModel defines the Terraform resource's data model.
type AccessKeysResourceModel struct {
	UserName        types.String `tfsdk:"user_name"`
	UserID          types.String `tfsdk:"user_id"` // Stored in state, computed
	Expires         types.String `tfsdk:"expires"`
	CreatedDate     types.String `tfsdk:"created_date"`
	ID              types.String `tfsdk:"id"`
	AccessKey       types.String `tfsdk:"access_key"`
	SecretAccessKey types.String `tfsdk:"secret_access_key"`
	DisplayName     types.String `tfsdk:"display_name"`
	UserURN         types.String `tfsdk:"user_urn"`
	AccountID       types.String `tfsdk:"account_id"`
}

func (r *AccessKeysResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_access_keys"
}

func (r *AccessKeysResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a StorageGrid S3 Access Key for a specific user.",
		Attributes: map[string]schema.Attribute{
			"user_name": schema.StringAttribute{
				Description: "The name of the user for whom the access key will be created.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"user_id": schema.StringAttribute{
				Description: "The internal ID of the user.",
				Computed:    true,
			},
			"expires": schema.StringAttribute{
				Description: "The expiration date for the access key in ISO 8601 format (e.g., '2028-09-04T00:00:00.000Z'). If omitted, the key will not expire.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"created_date": schema.StringAttribute{
				Description: "A timestamp of when the key was created in Terraform. Changing this value will force a new key to be generated.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": schema.StringAttribute{
				Description: "The unique identifier for the access key, generated by StorageGrid.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"access_key": schema.StringAttribute{
				Description: "The S3 access key. This value is only available upon creation and is stored in the Terraform state.",
				Computed:    true,
				Sensitive:   true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"secret_access_key": schema.StringAttribute{
				Description: "The S3 secret access key. This value is only available upon creation and is stored in the Terraform state.",
				Computed:    true,
				Sensitive:   true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"display_name": schema.StringAttribute{
				Description: "The display name of the access key.",
				Computed:    true,
			},
			"user_urn": schema.StringAttribute{
				Description: "The URN of the user associated with the access key.",
				Computed:    true,
			},
			"account_id": schema.StringAttribute{
				Description: "The account ID to which the user belongs.",
				Computed:    true,
			},
		},
	}
}

func (r *AccessKeysResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*utils.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *utils.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

func (r *AccessKeysResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan AccessKeysResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Step 1: Get the User ID from the provided User Name.
	userName := plan.UserName.ValueString()
	apiUser, err := r.client.GetUser("user/" + userName)
	if err != nil {
		if strings.Contains(err.Error(), "status: 404") {
			resp.Diagnostics.AddError("User Not Found", fmt.Sprintf("Could not find user with name: '%s'", userName))
		} else {
			resp.Diagnostics.AddError("API Error", fmt.Sprintf("Failed to get user '%s': %s", userName, err.Error()))
		}
		return
	}
	userID := apiUser.Data.ID

	// Step 2: Create the access key using the fetched User ID.
	var payload utils.S3AccessKeyCreatePayload
	if !plan.Expires.IsNull() && !plan.Expires.IsUnknown() {
		expires := plan.Expires.ValueString()
		payload.Expires = &expires
	}

	createdKey, err := r.client.CreateS3AccessKey(userID, payload)
	if err != nil {
		resp.Diagnostics.AddError("Error Creating S3 Access Key", "Could not create S3 access key: "+err.Error())
		return
	}

	// Step 3: Populate the state with the response and computed values.
	keyData := createdKey.Data
	plan.UserID = types.StringValue(userID) // Save the fetched user ID to the state
	plan.ID = types.StringValue(keyData.ID)
	plan.AccessKey = types.StringValue(keyData.AccessKey)
	plan.SecretAccessKey = types.StringValue(keyData.SecretAccessKey)
	plan.DisplayName = types.StringValue(keyData.DisplayName)
	plan.UserURN = types.StringValue(keyData.UserURN)
	plan.AccountID = types.StringValue(keyData.AccountID)
	if keyData.Expires != "" {
		plan.Expires = types.StringValue(keyData.Expires)
	}

	if plan.CreatedDate.IsUnknown() || plan.CreatedDate.IsNull() {
		plan.CreatedDate = types.StringValue(time.Now().Format(time.RFC3339))
	}

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

func (r *AccessKeysResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state AccessKeysResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read uses the UserID stored in the state from the Create operation.
	userID := state.UserID.ValueString()
	if userID == "" {
		// This can happen if the resource was imported without the user_id being resolved.
		// We can attempt to resolve it now.
		userName := state.UserName.ValueString()
		apiUser, err := r.client.GetUser("user/" + userName)
		if err != nil {
			resp.Diagnostics.AddWarning("User Not Found on Read", fmt.Sprintf("Cannot find user '%s' to refresh access key state. If the user was deleted, the key is also gone.", userName))
			resp.State.RemoveResource(ctx)
			return
		}
		userID = apiUser.Data.ID
		state.UserID = types.StringValue(userID)
	}

	apiKeys, err := r.client.GetS3AccessKeys(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Error Reading StorageGrid S3 Access Keys", fmt.Sprintf("Could not read keys for user ID %s: %s", userID, err.Error()))
		return
	}

	var foundKey *utils.S3AccessKeyData
	for i := range apiKeys.Data {
		if apiKeys.Data[i].ID == state.ID.ValueString() {
			foundKey = &apiKeys.Data[i]
			break
		}
	}

	if foundKey == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	state.DisplayName = types.StringValue(foundKey.DisplayName)
	state.UserURN = types.StringValue(foundKey.UserURN)
	state.AccountID = types.StringValue(foundKey.AccountID)
	if foundKey.Expires != "" {
		state.Expires = types.StringValue(foundKey.Expires)
	} else {
		state.Expires = types.StringNull()
	}

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
}

func (r *AccessKeysResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	// Not implemented, as all configurable attributes require replacement.
}

func (r *AccessKeysResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state AccessKeysResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Delete uses the UserID and KeyID stored in the state.
	err := r.client.DeleteS3AccessKey(state.UserID.ValueString(), state.ID.ValueString())
	if err != nil {
		if strings.Contains(err.Error(), "status: 404") {
			return // Already gone, successful deletion.
		}
		resp.Diagnostics.AddError(
			"Error Deleting StorageGrid S3 Access Key",
			fmt.Sprintf("Could not delete key with ID %s for user ID %s: %s", state.ID.ValueString(), state.UserID.ValueString(), err.Error()),
		)
		return
	}
}
